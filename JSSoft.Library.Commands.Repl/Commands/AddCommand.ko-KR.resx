<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AddCommand" xml:space="preserve">
    <value>git-add - 인덱스에 파일 내용 추가</value>
  </data>
  <data name="AddCommand.DryRun" xml:space="preserve">
    <value>파일을 실제로 추가하지 말고 파일이 존재하는지 또는 무시되는지 표시하십시오.</value>
  </data>
  <data name="AddCommand.Forces" xml:space="preserve">
    <value>다른 방법으로 무시된 파일 추가 허용.</value>
  </data>
  <data name="AddCommand.Patch" xml:space="preserve">
    <value>대화식으로 인덱스와 워크 트리 사이의 패치 훈크를 선택하여 인덱스에 추가하십시오. 이를 통해 사용자는 지수에 수정된 내용을 추가하기 전에 차이점을 검토할 수 있다.

이렇게 하면 효과적으로 --interactive를 실행하지만 초기 명령 메뉴를 무시하고 패치 하위 명령으로 바로 이동한다. 자세한 내용은 "인터액티브 모드"를 참조하십시오.</value>
  </data>
  <data name="AddCommand.Interactive" xml:space="preserve">
    <value>작업 트리에서 대화식으로 수정된 내용을 인덱스에 추가하십시오. 작업 트리의 하위 집합으로 작동을 제한하기 위해 선택적 경로 인수를 제공할 수 있다. 자세한 내용은 "인터액티브 모드"를 참조하십시오.</value>
  </data>
  <data name="AddCommand.Path" xml:space="preserve">
    <value>콘텐츠를 추가할 파일. 일치하는 모든 파일을 추가하기 위해 파일 글로브(예: *.c)를 제공할 수 있다. 또한 선행 디렉토리 이름(예: dir/file1 및 dir/file2를 추가하여 dir/file2)을 부여하여 전체 디렉토리의 현재 상태에 맞게 색인을 업데이트할 수 있다(예: dir를 지정하면 working tree에서 수정된 file dir/file1만 기록할 것이 아니라 working tree에 추가된 file/file3도 기록됨). 이전 버전의 Git은 제거된 파일을 무시하는 데 사용되었습니다. 수정된 파일이나 새 파일을 추가하지만 제거된 파일은 무시하려면 --no-all 옵션을 사용하십시오.</value>
  </data>
  <data name="AddCommand.Verbose" xml:space="preserve">
    <value>장황하게 말하다.</value>
  </data>
  <data name="d:AddCommand" xml:space="preserve">
    <value>이 명령은 작업 트리에서 발견된 현재 내용을 사용하여 인덱스를 업데이트하여 다음 커밋을 위해 준비된 내용을 준비한다. 일반적으로 기존 경로 전체의 현재 내용을 추가하지만, 일부 옵션을 사용하면 적용된 작업 트리 파일에 대한 변경 사항의 일부만 있는 컨텐츠를 추가하거나, 작업 트리에 존재하지 않는 경로를 제거하는 데도 사용할 수 있다.

"인덱스"는 작업 트리의 내용에 대한 스냅샷을 가지고 있으며, 다음 커밋의 내용으로 촬영되는 것이 이 스냅샷이다. 따라서 작업 트리를 변경한 후 커밋 명령을 실행하기 전에 add 명령을 사용하여 새 파일이나 수정된 파일을 인덱스에 추가해야 한다.

이 명령은 커밋 전에 여러 번 수행할 수 있다. 추가 명령이 실행될 때 지정된 파일의 내용만 추가하며, 다음 커밋에 후속 변경사항을 포함하려면 git 추가를 다시 실행하여 새 내용을 인덱스에 추가해야 한다.

git status 명령을 사용하여 다음 커밋에 대해 스테이징된 변경사항이 있는 파일의 요약을 얻을 수 있다.

git add 명령은 기본적으로 무시된 파일을 추가하지 않는다. 명령줄에 무시된 파일이 명시적으로 지정된 경우 git 추가가 실패하고 무시된 파일 목록이 표시된다. 디렉터리 재귀 또는 Git(쉘보다 먼저 글로브를 인용함)이 수행하는 파일 이름 전역으로 도달한 무시된 파일은 자동으로 무시된다. git add 명령을 사용하여 -f(force) 옵션을 사용하여 무시된 파일을 추가할 수 있다.

콘텐츠를 커밋에 추가하는 다른 방법은 git-commit[1]을 참조하십시오.</value>
  </data>
</root>